# 标记整理为什么比标记复制慢

我们先来看一下标记复制算法的流程。

1. 遍历整个新生代的对象
2. 如果通过可达性算法分析过后，某个对象不是垃圾，就把该对象复制到幸存者to区。

整个复制算法的时间复杂度为O(n)。其中n为新生代对象的数量。

接下来我们再来看一下标记整理算法。

1. 第一步跟复制算法一样，也是遍历整个新生代对象。
2. 如果通过可达性算法分析过后，某个对象不是垃圾，就把该对象标记一下。
3. 等第一次标记完。jvm会再次重新遍历新生代的对象，把第一次标记过的已经存活的对象放到新生代区域的一端。

> 这里的关键是为什么整理算法不能像复制算法那样在第一遍历的时候就把已经标记的对象移动到新生代的一段呢？
>
> 这是因为这个遍历过程**并不是在堆内存里顺序遍历的，而是从多个GCROOT开始进行可达性遍历。**假设我们遇到存活的对象就移动到新生代的一端，可能会**覆盖掉某些GCROOT还没访问到的对象**。
>
> 所以说整理操作必须在第二次遍历的时候进行。

整个整理算法的时间复杂度为O(n)+O(n)。其中n为新生代对象的数量。

现在我们应该理解了为什么标记复制算法比标记整理算法快了。**标记复制算法的优势在于它可以在第一次遍历的时候就完成存活对象的移动操作。**

总结一下：

- 标记复制算法比标记整理算法快。
- 标记复制算法进行一次遍历就够了；而标记整理算法需要两次遍历。
- 标记复制算法的优势在于它可以在第一次遍历的时候就完成存活对象的移动操作。

以上。